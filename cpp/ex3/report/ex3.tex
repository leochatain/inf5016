\documentclass{article}
\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{times}
\usepackage{framed}

\title{Laboratório 3}
\author{Leonardo Chatain}

\begin{document}
\maketitle

\section{Tarefa}

Implementar o algoritmo de Ford-Fulkerson com a estratégia do ``caminho mais gordo'' (fattest path)
s-t.

Verificar que a complexidade observada é $ O((nlogn + m)m log C) $.

\section{Solução}

Implementei o algoritmo de Ford-Fulkerson usando:

\begin{itemize}
 \item Um multimap (\texttt{map<int, map<int, int>})
\end{itemize}

Implementei o algoritmo de Dijkstra usando um heap de Van Emde Boas, como visto em aula. Heaps de
Van Emde Boas realizam as operações \emph{insert} - no código: \emph{push(T val)} -,
\emph{deletemin} - no código: \emph{pop()} -, e \emph{update} - no código: \emph{update(T val, T
new)} com complexidade $ \log n $ (onde \emph{n} é o número de vértices do grafo).

Para o desenvolvimento foi utilizada a linguagem C++ e o compilador gcc versão 4.6. Para os testes
foi utilizado o framework CppUnit.

\section{Ambiente de teste}

Os resultados foram obtidos utilizando-se um \emph{Intel core i5}, com um processador de $2.27$ GHz
e $4$ GB de RAM.

\section{Resultados}


\section{Conclusão}

A complexidade não equivale à esperada, provavelmente porque o tamanho da entrada não é grande o
suficiente ($\log\log n$ provavelmente requer um tamanho grande na entrada para produzir uma
diferença relevante no tempo.

Também pudemos notar que Van Emde Boas é muito mais lento que um heap binário na prática, em grande
parte devido à alta complexidade da estrutura de Van Emde Boas. Outro fator interessante é que o
segundo $\log$ nos ganha muito pouco com relação ao primeiro $\log$, e isso é provavelmente
suficiente para que uma estrutura $\log\log$ não valha a pena.

\end{document}
% Local Variables:
% auto-fill-function: do-auto-fill
% TeX-PDF-mode: t
% fill-column: 110
% ispell-local-dictionary: "brasileiro"
% mode-name: "LaTeX"
% End:
